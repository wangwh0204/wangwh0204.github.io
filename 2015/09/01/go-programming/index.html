
 <!DOCTYPE HTML>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  
    <title>Go语言编程 | From Computer Vision to AGI Robots</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="steven wang">
    

    
    <meta name="description" content="&amp;lt;&amp;lt;Go语言编程&amp;gt;&amp;gt;读书笔记，内容泛泛而谈，简单而不深入，更像个人的BLOG文章，而不是书籍。花了2周时间看完.">
<meta name="keywords" content="Go">
<meta property="og:type" content="article">
<meta property="og:title" content="Go语言编程">
<meta property="og:url" content="https://wangwh0204.github.io/2015/09/01/go-programming/index.html">
<meta property="og:site_name" content="From Computer Vision to AGI Robots">
<meta property="og:description" content="&amp;lt;&amp;lt;Go语言编程&amp;gt;&amp;gt;读书笔记，内容泛泛而谈，简单而不深入，更像个人的BLOG文章，而不是书籍。花了2周时间看完.">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2015-09-10T16:00:00.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Go语言编程">
<meta name="twitter:description" content="&amp;lt;&amp;lt;Go语言编程&amp;gt;&amp;gt;读书笔记，内容泛泛而谈，简单而不深入，更像个人的BLOG文章，而不是书籍。花了2周时间看完.">

    
    
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/logo.jpg" alt="From Computer Vision to AGI Robots" title="From Computer Vision to AGI Robots"/></a>
			</div>
			
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="From Computer Vision to AGI Robots">From Computer Vision to AGI Robots</a></h1>
				<h2 class="blog-motto">在智能机器的寒武纪时代浪潮中，做点微小工作</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="菜单">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="搜索" />
						<input type="hidden" name="q" value="site:wangwh0204.github.io">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/09/01/go-programming/" title="Go语言编程" itemprop="url">Go语言编程</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="steven wang" target="_blank" itemprop="author">steven wang</a>
		
  <p class="article-time">
    <time datetime="2015-08-31T16:00:00.000Z" itemprop="datePublished"> 发表于 2015-09-01</time>
    
  </p>
</header>
	<div class="article-content">
		
		<div id="toc" class="toc-article">
			<strong class="toc-title">文章目录</strong>
		
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#01-初识Go语言"><span class="toc-number">1.</span> <span class="toc-text">01 初识Go语言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#02-顺序编程"><span class="toc-number">2.</span> <span class="toc-text">02 顺序编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#匿名函数和闭包"><span class="toc-number">2.1.</span> <span class="toc-text">匿名函数和闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#错误处理"><span class="toc-number">2.2.</span> <span class="toc-text">错误处理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#03-面向对象编程"><span class="toc-number">3.</span> <span class="toc-text">03 面向对象编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#接口"><span class="toc-number">3.1.</span> <span class="toc-text">接口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#04-并发编程"><span class="toc-number">4.</span> <span class="toc-text">04 并发编程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#05-网络编程"><span class="toc-number">5.</span> <span class="toc-text">05 网络编程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#06-安全编程"><span class="toc-number">6.</span> <span class="toc-text">06 安全编程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#07-工程管理"><span class="toc-number">7.</span> <span class="toc-text">07 工程管理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#08-开发工具"><span class="toc-number">8.</span> <span class="toc-text">08 开发工具</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#09-进阶话题"><span class="toc-number">9.</span> <span class="toc-text">09 进阶话题</span></a></li></ol>
		
		</div>
		
		<p>&lt;&lt;Go语言编程&gt;&gt;读书笔记，内容泛泛而谈，简单而不深入，更像个人的BLOG文章，而不是书籍。花了2周时间看完.<a id="more"></a></p>
<h1 id="01-初识Go语言"><a href="#01-初识Go语言" class="headerlink" title="01 初识Go语言"></a>01 初识Go语言</h1><p>Go语言的第一个版本在2009年11月正式对外发布。第一个正式版本的Go语言于2012年3月28日正式发布。<br>Go语言的主要作者：Ken Thompson， Rob Pike, Robert Griesemer, Russ Cox, Ian Lance Taylor, Brad Fitzpatrick</p>
<p>Go 语言最主要的特性：</p>
<ul>
<li>自动垃圾回收</li>
<li>更丰富的内置类型</li>
<li>函数多返回值</li>
<li>错误处理<br>Go语言引入3个关键字用于标准的错误处理流程：defer, panic, recover</li>
<li>匿名函数和闭包<br>在Go语言中，所有的函数也是值类型，可以作为参数传递。</li>
<li>类型和接口</li>
<li>并发编程<br>Go语言引入了goroutine概念，它使得并发编程变得非常简单。通过在函数调用前使用关键字go，即可让该函数以goroutine方式执行。</li>
<li>反射</li>
<li>语言交互性<br>在Go代码中，可以按Cgo的特定语法混合编写C语言代码，然后Cgo工具可以将这些混合的C代码提取并生成对于C功能的调用包装代码。开发者基本上<br>可以完全忽略Go语言和C语言的边界是如何跨越的。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"Hello, world. 你好，世界!"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每个Go源代码文件的开头都是一个package声明，表示该Go代码所属的包。包是Go语言里的最基本的分发单位，也是工程管理中依赖关系的体现。</p>
<p>有一点需要注意，不得包含在源代码文件中没有用到的包，否则Go编译器会报编译错误。这与下面提到的强制左花括号{的放置位置以及之后提到的函数名大小写<br>规则，均体现了Go语言在语言层面解决软件工程问题的设计哲学。</p>
<p>func 函数名(参数列表)(返回值列表) {<br>}</p>
<p>func Compute(value1 int, value2 float64)(result float64, err error) {<br>}</p>
<p>Go命令行工具的革命性之处在于彻底消除了工程文件的概念，完全用目录结构和包名来推导工程结构和构建顺序。</p>
<h1 id="02-顺序编程"><a href="#02-顺序编程" class="headerlink" title="02 顺序编程"></a>02 顺序编程</h1><p>对于纯粹的变量声明，Go语言引入了关键字var,而类型信息放在变量名之后，示例如下：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v1 <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> v2 <span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> v3 [<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> v4 []<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> v5 <span class="keyword">struct</span> &#123;</span><br><span class="line">   f <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> v6 *<span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> v7 <span class="keyword">map</span>[<span class="keyword">string</span>] <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> v8 <span class="function"><span class="keyword">func</span><span class="params">(a <span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br></pre></td></tr></table></figure></p>
<p>通过const关键字，可以给字面常量指定一个友好的名字：<br>const zero = 0.0</p>
<p>Go语言预定义了这些常量：true, false和iota<br>itoa比较特殊，可以被认为是一个可被编译器修改的常量，在每一个const关键字出现时被重置为0，然后在下一个const出现之前，每出现一次iota，其所代表的数字自动增1.</p>
<p>Go语言并不支持enum关键字，而是使用const后跟一对圆括号的方式定义一组常量来定义：<br>const (<br>  Sunday = iota<br>  Monday<br>  Tuesday<br>  Wednesday<br>  Thursday<br>  Friday<br>  Saturday<br>  numberofDays<br>)</p>
<p>Go语言内置以下基础类型：</p>
<ul>
<li>布尔类型: bool</li>
<li>整形: int8, byte, int16, int, uint, uintptr</li>
<li>浮点类型：float32, float64</li>
<li>复数类型： complex64, complex128</li>
<li>字符串：string</li>
<li>字符类型：rune</li>
<li>错误类型：error</li>
</ul>
<p>此外，Go语言也支持以下复合类型：</p>
<ul>
<li>指针(pointer)</li>
<li>数组(array)</li>
<li>切片(slice)</li>
<li>字典(map)</li>
<li>通道(chan)</li>
<li>结构体(struct)</li>
<li>接口(interface)</li>
</ul>
<p>数组的长度在定义之后无法再次修改，数组是值类型，每次传递都将产生一份副本。Go语言提供了slice来弥补数组的不足。</p>
<p>数组切片可以基于一个已经存在的数组创建:<br>var myArray [10]int = [10]int {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}<br>var mySlice []int = myArray[:5]</p>
<p>也可以通过make函数直接创建:<br>mySlice1 := make([]int, 5)</p>
<p>既可以使用下标来遍历元素：<br>for i := 0; i &lt; len(mySlice); i++ {<br>  fmt.Println(“mySlice[“, i, “] =”, mySlice[i])<br>}<br>也可以使用range关键字：<br>for i, v : range mySlice {<br>  fmt.Println(“mySlice[“, i, “] =”, v)<br>}</p>
<p>Go语言支持如下的几种流程控制语句：</p>
<ul>
<li>条件语句 : if, else, else if<br>if a &lt; 5 {<br>return 0<br>} else {<br>return 1<br>}<ul>
<li>条件语句不需要使用括号将条件包含起来;</li>
<li>无论语句体内有几条语句，花括号{}都是必须存在的；</li>
<li>左花括号{必须与if或者else处于同一行；</li>
<li>在if之后，条件语句之前，可以添加变量初始化语句，使用;间隔；</li>
<li>在有返回值的函数中，不允许将最终的return语句包含在if…else…结构中，否则会编译失败</li>
</ul>
</li>
<li><p>选择语句 : switch, case, select<br>switch i {<br>case 0:<br> fmt.Printf(“0”)<br>case 1:<br> fmt.Printf(“1”)<br>case 2:<br> fallthrough<br>case 3:<br> fmt.Printf(“3”)<br>case 4, 5, 6:<br> fmt.Printf(“4, 5, 6”)<br>default:<br> fmt.Printf(“Default”)<br>}</p>
<ul>
<li>左花括号{必须与switch处于同一行；</li>
<li>条件表达式不限制为常量或者整数；</li>
<li>单个case中，可以出现多个结果选项；</li>
<li>与C语言等规则相反，Go语言不需要用break来明确退出一个case；</li>
<li>只有在case中明确添加fallthrough关键字，才会继续执行紧跟的下一个case；</li>
<li>可以不设定switch之后的条件表达式，在此种情况下，整个switch结构与多个if…else…的逻辑作用等同</li>
</ul>
</li>
<li><p>循环语句 : for, range<br>Go语言中的循环语句只支持for关键字，而不支持while和do-while结构。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">  sum += i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>无限循环:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">  sum++</span><br><span class="line">  <span class="keyword">if</span> sum &gt; <span class="number">100</span> &#123;</span><br><span class="line">   <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>多重赋值：<br>a := []int {1, 2, 3, 4, 5, 6}<br>for i, j := 0, len(a) - 1; i &lt; j; i, j = i + 1, j - 1 {<br>  a[i], a[j] = a[j], a[i]<br>}</p>
<pre><code>- 左花括号{必须与for处于同一行
- Go语言中的for循环与C语言一样，都允许在循环条件种定义和初始化变量，唯一的区别是，Go语言不支持以逗号
为间隔的多个赋值语句，必须使用平行赋值的方式来初始化多个变量
- Go语言的for循环同样支持coutinue和break来控制循环，但是它提供了一个更高级的break，可以选择中断哪一个循环
</code></pre><ul>
<li>跳转语句 : goto </li>
</ul>
<p>与C，C++和JAVA等开发语言的一个极大不同在于，Go语言的函数或者成员的方法可以有多个返回值。比如File.Read()函数<br>可以同时返回读取的字节数和错误信息：<br>func (file *File) Read(b []byte) (n int, err Error)<br>我们可以给返回值命名，它们的值在函数开始的时候被自动初始化为空，在函数中执行不带任何参数的return语句时，会返回对应的返回值汴梁的值。</p>
<p>如果调用方调用了一个具有多返回值的方法，但却不关心某个返回值，可以使用下划线<em>来跳过此返回值：<br>n, </em> := f.Read(buf)</p>
<h2 id="匿名函数和闭包"><a href="#匿名函数和闭包" class="headerlink" title="匿名函数和闭包"></a>匿名函数和闭包</h2><p>匿名函数由一个不带函数名的函数声明和函数体组成：<br>func(a, b int, z float64) bool {<br>  return a*b &lt; int(z)<br>}<br>匿名函数可以直接赋值给一个变量<br>f := func(x, y int) int {<br>  return x + y<br>}<br>或者 直接执行<br>func(ch chan int) {<br>  ch &lt;- ACK<br>} (replay_chan) // 花括号后直接跟参数列表表示函数调用</p>
<p>Go的匿名函数是一个闭包(closure)。<br>闭包是可以包含自由变量的代码块，这些变量不在此代码块内或者任何全局上下文中定义，而是在定义代码块的环境中定义。</p>
<p>闭包的价值在于可以作为函数对象或者匿名函数。</p>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>Go语言引入了一个关于错误处理的标准模式，即error接口:<br>type error interface {<br>  Error() string<br>}</p>
<p>defer 关键字</p>
<p>Go语言引入了两个内置函数panic()和recover()以报告和处理运行时错误和程序中的错误场景。</p>
<h1 id="03-面向对象编程"><a href="#03-面向对象编程" class="headerlink" title="03 面向对象编程"></a>03 面向对象编程</h1><p>对于面向对象编程的支持，Go语言设计的非常简洁而优雅。Go语言并没有沿袭传统面向对象编程中的诸多概念，比如继承，虚函数，构造函数和析构函数，隐藏的this指针等。</p>
<p>func (a Integer) Less(b Integer) bool {<br>  return a &lt; b<br>}</p>
<p>func (a <em>Integer) Add(b Integer) {<br>  return </em>a += b<br>}</p>
<p>Go语言的结构体(struct)和其他语言的类(class)有同等的地位，但Go语言放弃了包括继承在内的大量面向对象特性，只保留了组合(composition)这个最基础的特性。</p>
<p>所有的Go语言类型(指针类型除外)都可以有自己的方法。例如，定义一个矩形类型：</p>
<p>type Rect struct {<br>  x, y float64<br>  width, height float64<br>}</p>
<p>定义成员方法Area()来计算矩形的面积：<br>func (r <em>Rect) Area() float64 {<br>  return r.width </em> r.height<br>}</p>
<p>在定义了Rect类型后，可以通过如下几种方法创建并初始化Rect类型的对象实例：<br>rect1 := new(Rect)<br>rect2 := &amp;Rect{}<br>rect3 := &amp;Rect{0, 0, 100, 200}<br>rect4 := &amp;Rect{width:100, height: 200}</p>
<p>在Go语言中，未进行显式初始化的变量都会被初始化为该类型的零值，例如bool类型的零值为false，int类型的零值为0，string类型的零值为空字符串。</p>
<p>在Go语言中没有构造函数的概念，对象的创建通常交由一个全局的创建函数来完成，以NewXXX来命名，表示”构造函数”:</p>
<p>func NewRect(x, y, width, height float64) *Rect {<br>  return &amp;Rect{x, y, width, height}<br>}</p>
<ul>
<li>匿名组合<br>确切的说，Go语言也提供了继承，但是采用了组合的文法。<br>type Base struct [<br>Name string<br>}</li>
</ul>
<p>func (base <em>Base) Foo() { … }<br>func (base </em>Base) Bar() { … }</p>
<p>type Foo struct {<br>  Base<br>  …<br>}</p>
<p>func (foo *Foo) Bar() {<br>  foo.Base.Bar()<br>  …<br>}</p>
<p>Go语言对关键字的增加非常吝啬，没有private, protected, public这样的关键字。要使某个符号对其他包可见，需要将该符号定义为以大写字母开头。</p>
<p>需要注意的一点是，Go语言中符号的可访问性是包一级而不是类型一级。也就是类的内部方法，在同一个包中的其他类型也都可以访问它。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口在Go语言有着至关重要的地位。如果说goroutine和channel是支撑起Go语言的并发模型的基石，让Go语言在如今集群化与多核化的时代成为一道极为亮丽的风景，那么接口是Go语言整个类型系统的基石，让Go语言在基础编程哲学的探索上达到了前所未有的高度。</p>
<p>在Go语言中，一个类只需要实现了接口要求的所有函数，我们就说这个类实现了该接口。</p>
<p>由于Go语言中任何对象实例都满足空接口interface{}, 所以interface{}看起来像是可以指向任何对象的Any类型.<br>相比而言，使用Go语言可以大幅降低代码量，从软件工程的角度而言，降低代码量不仅仅意味着工作量的降低，更重要的是产品质量更容易得到保障。</p>
<h1 id="04-并发编程"><a href="#04-并发编程" class="headerlink" title="04 并发编程"></a>04 并发编程</h1><p>就目前而言，并发包含以下几种主流的实现模型：</p>
<ul>
<li>多进程</li>
<li>多线程</li>
<li>异步IO</li>
<li>协程(Coroutine)<br>本质上是一种用户态线程，不需要操作系统进行抢占式调度，且在真正的实现中寄存于线程中，因此系统开销极小，可以有效提高线程的任务并发性，而避免多线程的缺点。</li>
</ul>
<p>线程之间通信采用共享内存的方式，为了保证共享内存的有效性，采用加锁方式，避免死锁或资源竞争。</p>
<p>Go语言在语言级别支持轻量级线程，叫goroutine。goroutine是Go语言中的轻量级线程实现，由Go runtime管理。</p>
<p>在一个函数调用前加go关键字，这次调用就会在一个新的goroutine中并发执行。当被调用的函数返回时，这个goroutine也自动结束。</p>
<p>工程上，有两种最常见的并发通信模型：共享数据和消息<br>Go语言提供的消息通信机制被称为channel</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Count</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">  ch &lt;- <span class="number">1</span></span><br><span class="line">  fmt.Println(<span class="string">"Counting"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  chs := <span class="built_in">make</span>([]<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">10</span>)</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">   chs[i] = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">   <span class="keyword">go</span> Count(chs[i])</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> _, ch := <span class="keyword">range</span>(chs) &#123;</span><br><span class="line">   &lt;-ch</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Go语言在语言级别支持select关键字，用于处理异步IO问题<br>Go语言没有提供直接的超时处理机制，但可以利用select机制：</p>
<p>// 首先，我们实现并执行一个匿名的超时等待函数<br>timeout := make(chan bool, 1)<br>go func() {<br>  time.Sleep(1e9) // 等待1秒钟<br>  timeout &lt;- true<br>}()</p>
<p>// 然后我们把timeout这个channel利用起来<br>select {<br>  case &lt;-ch:<br>   // 从ch中读取数据<br>  case &lt;-timeout:<br>   // 一直没有从ch读取到数据，但从timeout中读取到了数据<br>}</p>
<p>这种写法看起来是一个小技巧，但却是在Go语言开发中避免channel通信超时的最有效方法。<br>需要注意的是，在Go语言中channel本身也是一个原生类型，与map之类的类型地位一样，因此channel本身在定义后也可以通过channel来传递. 我们可以使用这个特性来实现*nix上非常常见的管道特性。</p>
<p>使用close()函数关闭channel</p>
<p>使用runtime.Gosched()函数可以主动出让时间片给其他goroutine</p>
<p>go语言包中的sync包提供两种锁类型：sync.Mutex和sync.RWMutex</p>
<h1 id="05-网络编程"><a href="#05-网络编程" class="headerlink" title="05 网络编程"></a>05 网络编程</h1><p>Go语言标准库里提供的net包，支持基于IP层，TCP/UDP层及更高层面(HTTP, FTP, SMTP)的网络操作，其中用于IP层的称为Raw Socket</p>
<p>Go语言标准库对传统的网络编程的过程(socket, bind, listen/connect, accept, send/receive)进行了<br>抽象和封装。无论我们期望使用什么协议建立什么形式的连接，都只需要调用net.Dial()即可.</p>
<p>func Dial(net, addr string) (Conn, error)</p>
<p>例子：<br>conn, err : = net.Dial(“tcp”, “192.168.0.10:2100”)</p>
<p>conn, err : = net.Dial(“udp”, “192.168.0.12:975”)</p>
<p>conn, err : = net.Dial(“ip4:icmp”, “www.baidu.com”)</p>
<p>目前，Dial()函数支持如下协议：”tcp”, “tcp4”(仅限ipv4), “tcp6”, “udp”, “udp4”, “udp6”, “ip”, “ip4”, “ip6”</p>
<p>在成功建立连接后，我们就可以进行数据的发送和接收。发送数据时，使用conn的Write()方法，接收数据使用Read()方法</p>
<p>Go语言标准库内建提供了net/http包，涵盖了HTTP客户端和服务端的具体实现。</p>
<ul>
<li>http客户端</li>
</ul>
<ol>
<li>net/http包的client类型提供了如下几个方法：</li>
</ol>
<p>func (c <em>Client) Get(url string) (r </em>Response, err error)<br>func (c <em>Client) Post(url string, bodyType string, body io.Reader) (r </em>Response, err<br>error)<br>func (c <em>Client) PostForm(url string, data url.Values) (r </em>Response, err error)<br>func (c <em>Client) Head(url string) (r </em>Response, err error)</p>
<p>func (c <em>Client) Do(req </em>Request) (resp *Response, err error)</p>
<ol>
<li>自定义http.Client</li>
</ol>
<ul>
<li>http服务端<br>使用net/http包提供的http.ListenAndServe()方法，可以在指定的地址监听：<br>func ListenAndServe(addr string, handler Handler) error</li>
</ul>
<p>如果想更多地控制服务端的行为，可以自定义http.Server :<br>s := &amp;http.Server {<br>  Addr: “:8080”,<br>  Handler: myHandler,<br>  ReadTimeout: 10 <em> time.Second,<br>  WriteTimeout: 10 </em> time.Second,<br>  MaxHeaderBytes: 1 &lt;&lt; 20,<br>}<br>s.ListenAndServe()</p>
<p>在Go中，标准库提供的net/rpc包实现了RPC协议需要的相关细节，开发者可以很方便地使用该包编写RPC的服务端和客户端程序，这使得用Go语言开发的多个进程之间的通信变得非常简单。</p>
<p>net/rpc包允许RPC客户端程序通过网络或是其他I/O调用一个远端对象的公开方法。</p>
<p>一个对象中只有满足如下这些条件的方法,才能被 RPC 服务端设置为可供远程访问:</p>
<ul>
<li>必须是在对象外部可公开调用的方法(首字母大写);</li>
<li>必须有两个参数,且参数的类型都必须是包外部可以访问的类型或者是Go内建支持的类型;</li>
<li>第二个参数必须是一个指针;</li>
<li>方法必须返回一个error类型的值。<br>以上4个条件,可以简单地用如下一行代码表示:<br>func (t <em>T) MethodName(argType T1, replyType </em>T2) error<br>在上面这行代码中,类型T、T1 和 T2 默认会使用 Go 内置的 encoding/gob 包进行编码解码。</li>
</ul>
<p>RPC 服务端可以通过调用 rpc.ServeConn 处理单个连接请求。多数情况下,通过 TCP 或<br>是 HTTP 在某个网络地址上进行监听来创建该服务是个不错的选择。</p>
<p>在 RPC 客户端,Go 的 net/rpc 包提供了便利的 rpc.Dial() 和 rpc.DialHTTP() 方法来与指定的 RPC 服务端建立连接。在建立连接之后,Go 的 net/rpc 包允许我们使用同步或者异步的方式接收 RPC 服务端的处理结果。调用 RPC 客户端的 Call() 方法则进行同步处理,这时候客户端程序按顺序执行,只有接收完 RPC 服务端的处理结果之后才可以继续执行后面的程序。当调用 RPC 客户端的Go() 方法时,则可以进行异步处理,RPC 客户端程序无需等待服务端的结果即可执行后面的程序,而当接收到 RPC 服务端的处理结果时,再对其进行相应的处理。无论是调用 RPC 客户端的 Call() 或者是 Go() 方法,都必须指定要调用的服务及其方法名称,以及一个客户端传入参数的引用,还有一个用于接收处理结果参数的指针。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">packageserver</span><br><span class="line"><span class="keyword">type</span> Args <span class="keyword">struct</span> &#123;</span><br><span class="line">  A, B <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Quotient <span class="keyword">struct</span> &#123;</span><br><span class="line">  Quo, Rem <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Arith <span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Arith)</span> <span class="title">Multiply</span><span class="params">(args *Args, reply *<span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  *reply = args.A * args.B</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *Arith)</span> <span class="title">Divide</span><span class="params">(args *Args, quo *Quotient)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> args.B == <span class="number">0</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> errors.New(<span class="string">"divide by zero"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  quo.Quo = args.A / args.B</span><br><span class="line">  quo.Rem = args.A % args.B</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注册服务对象并开启该 RPC 服务的代码如下:<br>arith := new(Arith)<br>rpc.Register(arith)<br>rpc.HandleHTTP()<br>l, e := net.Listen(“tcp”, “:1234”)<br>if e != nil {<br>log.Fatal(“listen error:”, e)<br>}<br>go http.Serve(l, nil)</p>
<p>此时,RPC 服务端注册了一个 Arith 类型的对象及其公开方法 Arith.Multiply() 和 rith.Divide()供 RPC 客户端调用。RPC 在调用服务端提供的方法之前,必须先与 RPC 服务端建立连接,如下列代码所示:<br>client, err := rpc.DialHTTP(“tcp”, serverAddress + “:1234”)<br>if err != nil {<br>log.Fatal(“dialing:”, err)<br>}</p>
<p>在建立连接之后,RPC 客户端可以调用服务端提供的方法。首先,我们来看同步调用程序顺序执行的方式:<br>args := &amp;server.Args{7,8}<br>var reply int<br>err = client.Call(“Arith.Multiply”, args, &amp;reply)<br>if err != nil {<br>  log.Fatal(“arith error:”, err)<br>}<br>fmt.Printf(“Arith: %d*%d=%d”, args.A, args.B, reply)</p>
<p>此外,还可以以异步方式进行调用,具体代码如下:<br>quotient := new(Quotient)<br>divCall := client.Go(“Arith.Divide”, args, &amp;quotient, nil)<br>replyCall := &lt;-divCall.Done</p>
<p>Gob 是 Go 的一个序列化数据结构的编码解码工具,在 Go 标准库中内置encoding/gob包以供使用。一个数据结构使用 Gob 进行序列化之后,能够用于网络传输。与 JSON 或 XML 这种基于文本描述的数据交换语言不同,Gob 是二进制编码的数据流,并且 Gob 流是可以自解释的,它在保证高效率的同时,也具备完整的表达能力。</p>
<p>作为针对 Go 的数据结构进行编码和解码的专用序列化方法,这意味着 Gob 无法跨语言使用。在 Go 的net/rpc包中,传输数据所需要用到的编码解码器,默认就是 Gob。由于 Gob 仅局限于使用 Go 语言开发的程序,这意味着我们只能用 Go 的 RPC 实现进程间通信。</p>
<p>Go 的net/rpc很灵活,它在数据传输前后实现了编码解码器的接口定义。这意味着,开发者可以自定义数据的传输方式以及 RPC 服务端和客户端之间的交互行为。</p>
<p>实际上,Go 标准库提供的net/rpc/json包,就是一套实现了rpc.ClientCodec和rpc.ServerCodec接口的 JSON-RPC 模块。</p>
<p>关于JSON的更多信息,请访问JSON官方网站 <a href="http://json.org/" target="_blank" rel="noopener">http://json.org/</a> 查阅。Go语言内建对JSON的支持。使用Go语言内置的encoding/json 标准库,开发者可以轻松使用Go程序生成和解析JSON格式的数据。在Go语言实现JSON的编码和解码时,遵循RFC4627协议标准。</p>
<p>使用 json.Marshal()函数可以对一组数据进行JSON格式的编码。 json.Marshal()函数的声明如下:<br>func Marshal(v interface{}) ([]byte, error)</p>
<p>可以使用 json.Unmarshal() 函数将JSON格式的文本解码为Go里边预期的数据结构。json.Unmarshal()函数的原型如下:<br>func Unmarshal(data []byte, v interface{}) error<br>该函数的第一个参数是输入,即JSON格式的文本(比特序列),第二个参数表示目标输出容器,用于存放解码后的值。要解码一段JSON数据,首先需要在Go中创建一个目标类型的实例对象,用于存放解码后<br>的值:<br>var book Book<br>然后调用 json.Unmarshal() 函数,将 []byte 类型的JSON数据作为第一个参数传入,将 book实例变量的指针作为第二个参数传入:<br>err := json.Unmarshal(b, &amp;book)</p>
<ol>
<li>渲染网页模板<br>使用Go标准库提供的html/template包,可以让我们将 HTML 从业务逻辑程序中抽离出来形成独立的模板文件,这样业务逻辑程序只负责处理业务逻辑部分和提供模板需要的数据,模板文件负责数据要表现的具体形式。然后模板解析器将这些数据以定义好的模板规则结合模板文件进行渲染,最终将渲染后的结果一并输出,构成一个完整的网页。</li>
</ol>
<h1 id="06-安全编程"><a href="#06-安全编程" class="headerlink" title="06 安全编程"></a>06 安全编程</h1><p>Go提供了MD5，SHA-A等几种hash函数crypto/</p>
<h1 id="07-工程管理"><a href="#07-工程管理" class="headerlink" title="07 工程管理"></a>07 工程管理</h1><p>Go语言在设计之初就考虑了在语言层面如何更好地解决当前工程管理中的一些常见问题。<br>本章我们将从以下方面介绍Go语言所引入的工程管理思想，工具和规范：</p>
<ul>
<li>代码风格</li>
<li>文档风格和管理</li>
<li>单元测试与性能测试方法</li>
<li>项目工程结构</li>
<li>跨平台开发</li>
<li>打包分发</li>
</ul>
<p>go 命令行工具可以完成以下几类工作：</p>
<ul>
<li>代码格式化</li>
<li>代码质量分析和修复</li>
<li>单元测试与性能测试</li>
<li>工程构建</li>
<li>代码文档的提取和展示</li>
<li><p>依赖包管理</p>
</li>
<li><p>代码风格<br>“代码必须是本着写给人阅读的原则来编写,只不过顺便给机器执行而已。”这段话来自&lt;&lt;计算机程序设计与解释&gt;&gt;,很精练地说明了代码风格的作用。代码风格,是一个与人相关、与机器无关的问题。代码风格的好坏,不影响编译器的工作,但是影响团队协同,影响代码的复用、演进以及缺陷修复。</p>
</li>
</ul>
<p>Go语言很可能是第一个将代码风格强制统一的语言。</p>
<blockquote>
<p>深得我心，个人对代码风格并没有特别得偏好，但在一个团队里面一定要有编码规范，且强制执行。问题是通常没有办法依靠人自己编码时自动执行，使用工具来达成是最好的办法，比如预先在IDE里面设定好编码规范，然后设置save时自动format。<br>go语言将代码规范作为语法层面来对待，减少了团队间不必要的沟通成本</p>
<p>无处不透露着实用主义，KISS的设计理念。将注意力放在要解决的问题本身，而不是语言本身。当一个语言本身的复杂性甚至超过了要解决的问题本身，语言变成了智力题</p>
</blockquote>
<p>命名规则涉及变量、常量、全局函数、结构、接口、方法等的命名。Go语言从语法层面进行了以下限定:任何需要对外暴露的名字必须以大写字母开头,不需要对外暴露的则应该以小写字母开头。</p>
<p>使用go fmt 自动格式化</p>
<ul>
<li><p>远程import支持<br>支持在语言级别调用远程的包。假如,我们有一个用于计算CRC32的包托管于Github,那么可以这样写:<br>package main<br>import (<br>“fmt”<br>“github.com/myteam/exp/crc32”<br>)<br>然后,在执行go build或者go install之前,只需要加这么一句:<br>go get github.com/myteam/exp/crc32</p>
</li>
<li><p>工程组织<br>GOPATH 这个环境变量是在讨论工程组织之前必须提到的内容。Gotool的大部分功能其实<br>已经不再针对当前目录,而是针对包名,于是如何才能定位到对应的源代码就落到了GOPATH<br>身上。</p>
</li>
</ul>
<p>一个标准的Go语言工程包含以下几个目录:src、pkg和bin。目录src用于包含所有的源代码,<br>是Gotool一个强制的规则,而pkg和bin则无需手动创建,如果必要Gotool在构建过程中会自动创<br>建这些目录。</p>
<p>构建过程中Gotool对包结构的理解完全依赖于src下面的目录结构,</p>
<ul>
<li>文档管理</li>
</ul>
<p>在传统开发中，同步设计文档和代码是一件非常困难的事情。一旦开始有一些细微的不一致，之后这个鸿沟将会越来越大，并最终导致文档完全废弃。Javadoc工具的出现开始逐步缓解文档和代码一致性的难题。Javadoc工具可以直接将注释提取并生成HTML格式的文档。</p>
<p>使用go doc 生成代码文档 </p>
<ul>
<li>跨平台开发<br>可以通过设置GOOS和GOARCH两个环境变量来指定交叉编译的目标格式。<br>$GOOS : darwin, freebsd, linux, windows<br>$GOARCH : 386, amd64, arm</li>
</ul>
<p>$ GOOS=windows GOARCH=386 go build -o hello.exe hello.go</p>
<ul>
<li>单元测试<br>Go本身提供了一套轻量级的测试框架。符合规则的测试代码会在运行测试时被自动识别并<br>执行。单元测试源文件的命名规则如下:在需要测试的包下面创建以“_test”结尾的go文件,形<br>如[^.]*_test.go。</li>
</ul>
<p>Go的单元测试函数分为两类:功能测试函数和性能测试函数,分别为以Test和Benchmark<br>为函数名前缀并以<em>testing.T为单一参数的函数。下面是测试函数声明的例子:<br>func TestAdd1(t </em>testing.T)<br>func BenchmarkAdd1(t *testing.T)</p>
<h1 id="08-开发工具"><a href="#08-开发工具" class="headerlink" title="08 开发工具"></a>08 开发工具</h1><p>goclipse : <a href="http://goclipse.github.io/releases/" target="_blank" rel="noopener">http://goclipse.github.io/releases/</a><br>eclipse的go语言插件</p>
<h1 id="09-进阶话题"><a href="#09-进阶话题" class="headerlink" title="09 进阶话题"></a>09 进阶话题</h1><ul>
<li>反射</li>
<li>语言交互性<br>package main</li>
</ul>
<p>import “fmt”<br>/*</p>
<p>#include <stdlib.h><br>*/<br>import “C”</stdlib.h></p>
<p>func Random() int {<br>  return int(C.random())<br>}<br>func Seed(i int) {<br>  C.srandom(C.uint(i))<br>}</p>
<p>func main() {<br>  Seed(100)<br>  fmt.Println(“Random:”, Random())<br>}</p>
<ul>
<li>goroutine机理</li>
<li>interface机理</li>
</ul>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/technology/">technology</a>
</div>


  <div class="article-tags">
  
  <span></span> <a href="/tags/Go/">Go</a>
  </div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="https://wangwh0204.github.io/2015/09/01/go-programming/" data-title="Go语言编程 | From Computer Vision to AGI Robots" data-tsina="null" class="share clearfix">
	  </div>
	
	</div>


</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2015/09/19/pro-html5-programming/" title="HTML5 高级程序设计">
  <strong>上一篇：</strong><br/>
  <span>
  HTML5 高级程序设计</span>
</a>
</div>


<div class="next">
<a href="/2015/08/17/mongodb-the-definitive-guide/"  title="MongoDB - The Definitive Guide">
 <strong>下一篇：</strong><br/> 
 <span>MongoDB - The Definitive Guide
</span>
</a>
</div>

</nav>

	

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="显示侧边栏"></a></div>

  <div id="toc" class="toc-aside">
  <strong class="toc-title">文章目录</strong>
 
 <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#01-初识Go语言"><span class="toc-number">1.</span> <span class="toc-text">01 初识Go语言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#02-顺序编程"><span class="toc-number">2.</span> <span class="toc-text">02 顺序编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#匿名函数和闭包"><span class="toc-number">2.1.</span> <span class="toc-text">匿名函数和闭包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#错误处理"><span class="toc-number">2.2.</span> <span class="toc-text">错误处理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#03-面向对象编程"><span class="toc-number">3.</span> <span class="toc-text">03 面向对象编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#接口"><span class="toc-number">3.1.</span> <span class="toc-text">接口</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#04-并发编程"><span class="toc-number">4.</span> <span class="toc-text">04 并发编程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#05-网络编程"><span class="toc-number">5.</span> <span class="toc-text">05 网络编程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#06-安全编程"><span class="toc-number">6.</span> <span class="toc-text">06 安全编程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#07-工程管理"><span class="toc-number">7.</span> <span class="toc-text">07 工程管理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#08-开发工具"><span class="toc-number">8.</span> <span class="toc-text">08 开发工具</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#09-进阶话题"><span class="toc-number">9.</span> <span class="toc-text">09 进阶话题</span></a></li></ol>
 
  </div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="隐藏侧边栏"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">分类</p>
		<ul>
		
		  
			<li><a href="/categories/IR/" title="IR">IR<sup>3</sup></a></li>
		  
		
		  
		
		  
		
		  
			<li><a href="/categories/management/" title="management">management<sup>5</sup></a></li>
		  
		
		  
		
		  
		
		  
		
		  
			<li><a href="/categories/technology/" title="technology">technology<sup>20</sup></a></li>
		  
		
		  
		
		  
			<li><a href="/categories/thinking/" title="thinking">thinking<sup>3</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">标签</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/Stanford/" title="Stanford">Stanford<sup>7</sup></a></li>
			
		
			
				<li><a href="/tags/Computer-Graphics/" title="Computer Graphics">Computer Graphics<sup>5</sup></a></li>
			
		
			
				<li><a href="/tags/Unity/" title="Unity">Unity<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Computer-Vision/" title="Computer Vision">Computer Vision<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/MR/" title="MR">MR<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Hololens/" title="Hololens">Hololens<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Agile/" title="Agile">Agile<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/OS/" title="OS">OS<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/SE/" title="SE">SE<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/OpenGL/" title="OpenGL">OpenGL<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/VR/" title="VR">VR<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/UML/" title="UML">UML<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Robotics/" title="Robotics">Robotics<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Machine-Learning/" title="Machine Learning">Machine Learning<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Robot-Learning/" title="Robot Learning">Robot Learning<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Robot-Manipulation/" title="Robot Manipulation">Robot Manipulation<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/Web/" title="Web">Web<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Design-Patterns/" title="Design Patterns">Design Patterns<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/git/" title="git">git<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/github/" title="github">github<sup>1</sup></a></li>
			
		
		</ul>
</div>


  
  <div class="archiveslist">
    <p class="asidetitle"><a href="/archives">归档</a></p>
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">一月 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/06/">六月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">五月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">四月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">一月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">十月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">一月 2016</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">十二月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">十一月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">十月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">九月 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">八月 2015</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/09/">九月 2011</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/08/">八月 2011</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/06/">六月 2011</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/04/">四月 2011</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/02/">二月 2011</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2008/10/">十月 2008</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2006/08/">八月 2006</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2006/01/">一月 2006</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2005/03/">三月 2005</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2004/09/">九月 2004</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2004/06/">六月 2004</a><span class="archive-list-count">1</span></li></ul>
  </div>


  <div class="linkslist">
  <p class="asidetitle">友情链接</p>
    <ul>
        
          <li>
            
            	<a href="http://cs.stanford.edu/" target="_blank" title="Stanford CS">Stanford CS</a>
            
          </li>
        
          <li>
            
            	<a href="http://pair.stanford.edu/" target="_blank" title="Stanford PAIR">Stanford PAIR</a>
            
          </li>
        
          <li>
            
            	<a href="https://www.ri.cmu.edu/" target="_blank" title="CMU RI">CMU RI</a>
            
          </li>
        
          <li>
            
            	<a href="https://www.robot-learning.org/" target="_blank" title="CORL">CORL</a>
            
          </li>
        
          <li>
            
            	<a href="https://www.paperswithcode.com/sota" target="_blank" title="SOTA">SOTA</a>
            
          </li>
        
    </ul>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> You&#39;ve got to find what you love. And the only way to do great work is to love what you do. If you haven&#39;t found it yet, keep looking. Don&#39;t settle. ― Steve Jobs <br/>
			I&#39;m not a great programmer; I&#39;m just a good programmer with great habits. ― Kent Beck</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		<a href="https://github.com/wangwh0204" target="_blank" class="icon-github" title="github"></a>
		
		
		
		
		
		
		
		<a href="http://www.zhihu.com/people/wangwh0204" target="_blank" class="icon-zhihu" title="知乎"></a>
		
		
		
		<a href="mailto:wangwh0204@outlook.com" target="_blank" class="icon-email" title="Email Me"></a>
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2020 
		
		<a href="/about" target="_blank" title="steven wang">steven wang</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
      
      $('#toc.toc-aside').css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a class="overlay" id="qrcode"></a>',
  '<a href="https://www.facebook.com/sharer.php?u=' + encodedUrl + '" class="article-share-facebook" target="_blank" title="Facebook"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="#qrcode" class="article-share-qrcode" title="微信"></a>',
  '<a href="http://widget.renren.com/dialog/share?resourceUrl=' + encodedUrl + '&srcUrl=' + encodedUrl + '&title=' + title +'" class="article-share-renren" target="_blank" title="人人"></a>',
  '<a href="http://service.weibo.com/share/share.php?title='+title+'&url='+encodedUrl +'&ralateUid='+ tsina +'&searchPic=true&style=number' +'" class="article-share-weibo" target="_blank" title="微博"></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>









<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="返回顶部"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
